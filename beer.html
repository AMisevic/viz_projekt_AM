<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Beer consumption in the World over the years</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <header>
    <h1>Beer consumption in the World over the years</h1>
  </header>

  <div id="content">
    <div id="main-content">
      <div id="controls">
        <div class="control-group">
          <label for="yearSlider">Year: <span id="yearLabel"></span></label>
          <input type="range" id="yearSlider" min="1960" max="2019" value="2019" step="1" />
        </div>
        <div class="control-group">
          <label for="regionSelect">Region:</label>
          <select id="regionSelect">
            <option value="World">World</option>
            <option value="Africa">Africa</option>
            <option value="Asia">Asia</option>
            <option value="Europe">Europe</option>
            <option value="North America">North America</option>
            <option value="South America">South America</option>
            <option value="Oceania">Oceania</option>
          </select>
        </div>
      </div>
      <svg></svg>
      <div id="tooltip"></div>
    </div>

    <div id="side-panel">
      <h2>Top consumers for the year</h2>
      <svg id="world-barplot"></svg>
      <h2>Consumption ranges</h2>
      <svg id="consumption-piechart"></svg>
    </div>
  </div>

  <footer>
    <p id="description">
        This segment is meant to give further information about what is being shown on the page. As the title states we are looking at beer consumption in the world over the years. The data being 
        shown on the map is in liters, but it does not mean liters of beer but instead liters of pure alcohol consumed in form of beer. This in other words means that 1L on the map corelates to 20L
        of beer. The map itself shows annual or in other words yearly consumption of beer per capita, in other words by a single person. 
    </p>
  </footer>
  

  <script>
    const svg = d3.select("svg");
    const svgNode = svg.node();
    const width = svgNode.getBoundingClientRect().width;
    const height = svgNode.getBoundingClientRect().height;
    const tooltip = d3.select("#tooltip");

    let selectedCountry = null;
    let currentRegion = "World";

    const projection = d3.geoMercator()
      .scale(160)
      .translate([width / 2, height / 1.5]);

    const path = d3.geoPath().projection(projection);

    const regionZoom = {
      "World": { scale: 160, center: [0, 20] },
      "Africa": { scale: 400, center: [20, 0] },
      "Asia": { scale: 300, center: [100, 30] },
      "Europe": { scale: 500, center: [20, 50] },
      "North America": { scale: 300, center: [-100, 40] },
      "South America": { scale: 350, center: [-60, -15] },
      "Oceania": { scale: 400, center: [140, -25] }  
    };

    const colorScale = d3.scaleLinear()
      //alternativna domena je [0, 2, 4, 6, 8, 10] iako mislim da je trenutna malo bolja u svrhu prikaza
      .domain([0, 1, 3, 5, 7, 9])
      .range([
        "#f9f871", // Lager
        "#f6e27f", // Pilsner
        "#f5b041", // Pale Ale
        "#d35400", // IPA
        "#a04000", // Amber
        "#3e2723", // Stout 
      ]);

    let beerDataByYear = {};

    const yearSlider = d3.select("#yearSlider");
    const yearLabel = d3.select("#yearLabel");

    const nameMap = {
      "United States of America": "United States",
      "USA": "United States", 
      "England": "United Kingdom", 
      "Republic of the Congo": "Congo",
      "Democratic Republic of the Congo": "Democratic Republic of Congo",
      "Ivory Coast": "Cote d'Ivoire",
      "United Republic of Tanzania": "Tanzania",
      "Guinea Bissau": "Guinea-Bissau"
    }

    Promise.all([
      d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"),
      d3.csv("beer-consumption-per-person.csv")
    ]).then(([geoData, beerData]) => {
      //console.log(beerData.slice(0, 5));
      
      beerData.forEach(d => {
        const country = d.Entity;
        const year = +d.Year;
        const value = +d.BeerValue;

        if (!beerDataByYear[year]) beerDataByYear[year] = {};
        beerDataByYear[year][country] = value;
      });

      //console.log("beerDataByYear example:", beerDataByYear[2001]); 

      const countries = geoData.features;

      const g = svg.append("g");

      const paths = g.selectAll("path")
        .data(countries)
        .join("path")
        .attr("class", "country")
        .attr("d", path)
        .on("mouseover", function (event, d) {
          const rawName = d.properties.name;
          const name = nameMap[rawName] || rawName;
          const year = yearSlider.property("value");
          const data = beerDataByYear[year]?.[name];

          //console.log("Hovering:", rawName, "->", name, "->", data);

          tooltip
            .style("opacity", 1)
            .html(`<strong>${name}</strong><br/>Beer: ${data ? data : "N/A"} L`);
        })
        .on("mousemove", function (event) {
          tooltip.style("left", (event.pageX + 10) + "px")
                 .style("top", (event.pageY - 20) + "px");
        })
        .on("mouseout", function () {
          tooltip.style("opacity", 0);
        })
        .on("click", function (event, d) {
          const rawName = d.properties.name;
          const name = nameMap[rawName] || rawName;

          if (selectedCountry === name) {
            // Clicking again on the same country: reset to region/world
            selectedCountry = null;
            const zoom = regionZoom[currentRegion];

            projection
              .scale(zoom.scale)
              .center(zoom.center)
              .translate([width / 2, height / 2]);

            const newPath = d3.geoPath().projection(projection);
            g.selectAll("path").transition().duration(750).attr("d", newPath);

            g.transition().duration(750).attr("transform", null);

            //console.log("Unselected country, returning to region:", currentRegion);
          } else {
            selectedCountry = name;

            const [[x0, y0], [x1, y1]] = path.bounds(d);
            const dx = x1 - x0;
            const dy = y1 - y0;
            const x = (x0 + x1) / 2;
            const y = (y0 + y1) / 2;

            const scale = Math.min(8, 0.9 / Math.max(dx / width, dy / height));
            const translate = [width / 2 - scale * x, height / 2 - scale * y];

            g.transition().duration(750)
              .attr("transform", `translate(${translate}) scale(${scale})`);

            //console.log("Selected country:", selectedCountry);
          }

          g.selectAll("path").classed("selected", d2 => {
            const name2 = nameMap[d2.properties.name] || d2.properties.name;
            return name2 === selectedCountry;
          })
        });

      updateMap(yearSlider.property("value"))
      if(currentRegion == "World"){
        updateWorldGraphs(yearSlider.property("value"));
        updateConsumptionPieChart(yearSlider.property("value"));
      }

      function updateMap(year) {
        yearLabel.text(year);
        paths.transition().duration(500)
          .attr("fill", d => {
            const name = nameMap[d.properties.name] || d.properties.name;
            const val = beerDataByYear[year]?.[name];
            return val ? colorScale(val) : "#ccc";
          });
      }

      function updateWorldGraphs(year) {
        const svg = d3.select("#world-barplot");
        svg.selectAll("*").remove(); // Clear previous graph

        const margin = { top: 20, right: 30, bottom: 40, left: 100 };
        const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
        const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;

        const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

        // Get beer data for the year
        const yearData = beerDataByYear[year];
        if (!yearData) return;

        const data = Object.entries(yearData)
          .map(([country, value]) => ({ country, value }))
          .filter(d => d.value != null && !isNaN(d.value))
          .sort((a, b) => b.value - a.value)
          .slice(0, 10);

        const x = d3.scaleLinear()
          .domain([0, d3.max(data, d => d.value)])
          .range([0, width]);

        const y = d3.scaleBand()
          .domain(data.map(d => d.country))
          .range([0, height])
          .padding(0.1);

        g.append("g")
          .call(d3.axisLeft(y));

        g.append("g")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(x).ticks(5));

        g.selectAll("rect")
          .data(data)
          .join("rect")
          .attr("x", 0)
          .attr("y", d => y(d.country))
          .attr("width", d => x(d.value))
          .attr("height", y.bandwidth())
          .attr("fill", "#a04000"); // Nice amber beer tone
      }  
      
      function updateConsumptionPieChart(year) {
        const svg = d3.select("#consumption-piechart");
        svg.selectAll("*").remove(); // Clear previous chart

        const margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
        const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
        const radius = Math.min(width, height) / 2;

        const g = svg.append("g")
          .attr("transform", `translate(${margin.left + width / 2},${margin.top + height / 2})`);

        const yearData = beerDataByYear[year];
        if (!yearData) return;

        const ranges = [
          { label: "< 1L", min: 0, max: 1 },
          { label: "1L - 3L", min: 1, max: 3 },
          { label: "3L - 5L", min: 3, max: 5 },
          { label: "> 5L", min: 5, max: Infinity }
        ];

        const counts = ranges.map(range => ({
          label: range.label,
          count: Object.values(yearData).filter(v => v >= range.min && v < range.max).length
        }));

        const color = d3.scaleOrdinal()
          .domain(ranges.map(d => d.label))
          .range(["#f9f871", "#f5b041", "#d35400", "#3e2723"]);

        const pie = d3.pie()
          .value(d => d.count);

        const arc = d3.arc()
          .innerRadius(0)
          .outerRadius(radius);

        const outerArc = d3.arc()
          .innerRadius(radius * 1.05)
          .outerRadius(radius * 1.05);

        const arcs = g.selectAll("arc")
          .data(pie(counts))
          .join("g")
          .attr("class", "arc");

        arcs.append("path")
          .attr("d", arc)
          .attr("fill", d => color(d.data.label));

        arcs.append("text")
          .attr("transform", d => {
            const pos = outerArc.centroid(d);
            pos[0] = pos[0] > 0 ? pos[0] + 10 : pos[0] - 10;
            return `translate(${pos})`;
          })
          .attr("text-anchor", d => outerArc.centroid(d)[0] > 0 ? "start" : "end")
          .attr("font-size", "12px")
          .attr("fill", "#222")
          .text(d => `${d.data.label}: ${d.data.count}`); // kao što je viljivo ne radi se o postotku nego o konkretnom broju naspram ukupno država
      }

      yearSlider.on("input", function () {
        updateMap(this.value);
        if(!selectedCountry && currentRegion === "World"){
          updateWorldGraphs(this.value);
          updateConsumptionPieChart(this.value);
        }
      });

      d3.select("#regionSelect").on("change", function () {
        selectedCountry = null;
        const region = this.value;
        currentRegion = region;
        const zoom = regionZoom[region];

        const oldScale = projection.scale();
        const oldCenter = projection.center();

        const newScale = zoom.scale;
        const newCenter = zoom.center;

        const interpolateScale = d3.interpolateNumber(oldScale, newScale);
        const interpolateCenter = d3.interpolateArray(oldCenter, newCenter);

        d3.transition()
          .duration(1000)
          .tween("zoom", () => {
            return function (t) {
              projection
                .scale(interpolateScale(t))
                .center(interpolateCenter(t))
                .translate([width / 2, height / 2]);

              const newPath = d3.geoPath().projection(projection);
              g.selectAll("path").attr("d", newPath);
            };
          });

        updateMap(yearSlider.property("value"));
        if(region === "World"){
          updateWorldGraphs(yearSlider.property("value"));
          updateConsumptionPieChart(yearSlider.property("value"))
        } else {
          d3.select("#world-barplot").selectAll("*").remove();
          d3.select("#consumption-piechart").selectAll("*").remove();
        }
      });
    });
  </script>
</body>
</html>